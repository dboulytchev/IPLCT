\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{listings}
\usepackage{xspace}

\newcommand{\lama}{$\lambda\kern -.1667em\lower -.5ex\hbox{$a$}\kern -.1000em\lower .2ex\hbox{$\mathcal M$}\kern -.1000em\lower -.5ex\hbox{$a$}$\xspace}

\begin{document}

\section{Языки программирования}

Наш курс посвящен компиляторам языков программирования, поэтому было бы разумно прежде всего обсудить, что такое, собственно,
языки программирования. В первом приближении можно сказать, что языки программирования~--- это языки для записи программ для компъютера.
Такое объяснение, при всей его тавтологичности, тем не менее содержит важное наблюдение: коль скоро языки программирования~--- это именно \emph{языки},
то есть знаковые системы, то для рассуждения о языках программирования следует применять понятийный аппарат \emph{семиотики} (науки о
знаковых системах).

Один из основателей этой науки, Чарльз Уильям Моррис (Charles William Morris), выделил три важных понятия:

\begin{itemize}
\item \emph{Синтаксис}~--- отношения знаков между собой.
\item \emph{Семантика}~--- отношения знакa к объекту.
\item \emph{Прагматика}~--- отношения знакa к субъекту.
\end{itemize}

В применении к языкам программирования синтаксис означает форму представления программ, семантика~--- их смысл, а прагматика~--- взаимодействие
языка программирования и программиста. Вопросы, связанные с прагматикой языков программирования, в нашем курсе рассматриваться не будут, а
вот синтаксис и семантика окажутся предметом особого внимания.

\section{Синтаксис}

Подобно естественным языкам, в синтаксисе языков программирования как правило можно выделить несколько уровней (лексика, грамматика и т.д.) Однако, в отличие
от естественных языков, которые развивались в значительной степени стихийно, языки программирования разрабатываются специально с
учетом определенных требований. В частности, синтаксис языков программирования \emph{однозначен} и приспособлен для эффективного автоматического анализа.

Для иллюстрации многоуровневого подхода с синтаксису рассмотрим следующий простой фрагмент на языке С. С точки зрения
\emph{лексики}, этот фрагмент является последовательностью \emph{лексем} (ключевое слово, разделитель, идентификатор, знак бинарной операции, десятичная константа и т.д.)
Эта последовательность лексем в свою очередь образует иерархию синтаксических конструкций (в данном случае, выражений и операторов).

Естественные языки как правило неоднозначны. Рассмотрим такую фразу на русском языке: ``Входя в двери лифта с животными, придерживайте их''. Придерживать кого? Двери или
животных? В данном случае мы имеем глобальную неоднозначность, которую невозможно разрешить даже путем анализа контекста. Единственный способ её устранить~--- это изменить фразу
(``Входя в лифт с животными, придерживайте двери'' либо ``Придерживайте животных, входя с ними в двери лифта''). Наличие такого рода неразрешимых неоднозначностей в
языках программирования недопустимо.

\section{Семантика}

Наиболее ярко отличия языков программирования от естественных языков проявляются на уровне семантики. Для языков программирования существуют формальные
средства спецификации их семантики, которые позволяют получить доказуемо надежные результаты.

Почему важна формальная семантика? Если в большинстве случаев при обычном программировании мы опираемся на неформальные представления о смысле программ,
то при разработке инструментальных средств, в частности, компиляторов, таких представлений оказывается недостаточно. Представим, например, что вам сказали,
что в каком-то языке программирования выражения состоят из переменных, констант и знаков четырех арифметических действий. Достаточно ли этой информации для
того, чтобы написать компилятор?

Рассмотрим следующие выражения:

\begin{lstlisting}
   0*(x/0)
  -x+1+x 
   x+1-1  
\end{lstlisting}      

Каков должен быть результат их вычисления? В первом случае, с одной стороны, умножение ноля на что угодно дает ноль, но здесь это ``что угодно'' не определено. Должен
ли получиться ноль или произойдет ошибка? Во втором случае мы вычитаем и прибавляем к единице значение одной и той же переменной \lstinline|x|. С одной стороны, это должно
дать единицу. С другой, что произойдет, если \lstinline|x| не определена? В третьем мы прибавляем к \lstinline|x| единицу и тут же её отнимаем. С одной стороны, это должно
дать значение \lstinline|x|, но что произойдет, если при прибавлении единицы произойдет переполнение (кстати, это же может случиться и в предыдущем примере)? Невозможность
ответить на эти вопросы ``устно'' не помешает нам писать программы, так как при наличии компилятора всегда можно на практике проверить, что происходит. Но что делать, если
нам предстоит написать первый в мире компилятор с этого языка? Как он должен ``пониимать'' такие программы? Что произойдет, если десяти разным людам поручат
написать компиляторы на основе такого описания? Не окажется ли, что мы получим десять несовместимых компиляторов, потому, что их авторы использовали разную трактовку
одного и того же неформального описания?

Для того, чтобы проиллюстрировать, как нас могут подвести интуитивные представления, рассмотрим пример небольшой программы на языке С. Язык С является одним из
наиболее распространённых в мире, он не считается ни трудным, ни ``эзотерическим'', поэтому можно ожидать, что любой человек, знакомый с этим языком, в
состоянии разобраться, что делает программа, состоящая из 12 строк. Вот эта программа.

Может показаться, что я вас обманываю, и что это не программа на языке С, а просто бессвязный набор символов. Проверим это. <демонстрация>

Как видим, для компилятора С эта совершенно непонятная для нас программа ничем не отличается от любой другой. Данная программа была разработана для конкурса по
``запутыванию программ'', больше подобных примеров можно найти на ресурсе https://www.cise.ufl.edu/~manuel/obfuscate/obfuscate.html. 

\section{Сущность трасляции}

Трансляция~--- это синтаксическое преобразование программ на одном языке в (эквивалентные) программы на другом. В возможности реализации автоматической
трансляции заключается важное отличие языков программирования от естественных языков. Несмотря на гигантский прогресс в области автоматического перевода
для естественных языков, качество этого перевода зачастую становится предметом дискуссий, и уж совершенно точно корректность трансляции для естественных
языков не может быть формально доказана (по крайней мере в обозримом будущем) просто по причине отсутствия для естественных языков формальной семантики.
Для трансляторов языков программирования эта проблема в значительной степени уже решена.

Сам транслятор~--- это программа, написанная на каком-то языке. Таким образом, когда мы говорим о трансляции, мы оперируем тремя языками:

\begin{itemize}
\item Языком, на котором написаны программы, которые мы транслируем. Этот язык называется \emph{исходный (source language)};
\item Языком, в который мы транслируем программы. Этот язык называется \emph{целевым (target language)};
\item Языком, на котором написан сам транслятор. Этот язык называется \emph{инструментальным}, или \emph{языком реализации}.
\end{itemize}

\section{Виды трансляторов}

Как вы, возможно, знаете, существует нечеткое разделение языков на языки высокого уровня и языки низкого уровня. Это разделение не дает какой-то абсолютной
классификации. Например, язык С относят к языкам высокого уровня, но, однако, практически никто не будет спорить, что по сравнению с Haskell С является
языком более низкого уровня. Многие языки высокого уровня обладают мощными системами типов, в отличие от большинства языков низкого уровня (но, тем не менее,
язык Scheme не типизирован, в то время как существуют типизированные ассемблеры), и т.д. Эта грубая классификация языков программирования приводит к следующей,
также грубой, классификации трансляторов.

Если транслятор преобразует программы с одного языка высокого уровня на другой язык высокого уровня, то его называют конвертором.

Компилятором называют транслятор, который преобразует программы на языке выского уровня в программы на языке низкого уровня, например, языке ассемблера
какой-либо аппаратной платформы.

Инструмент, который производит преобразование в обратную сторону, называют декомпилятором.

Наконец, трансляцию между бинарными представлениями машинного кода для разных платформ осуществляет бинарный транслятор.

Общепринята точка зрения, что среди всех этих разновидностей именно реализация компилятора представляет собой наиболее хитрую задачу. Мы
не будем с этим спорить (собственно, поэтому мы и занимаемся именно компилятором), но отметим, что и в других областях трансляции
существуют интересные и трудные задачи. Например, от конвертора и декомпилятора ожидают, что результат их деятельности будет использовать
естественные абстракции целевого языка, будет читаемым и сопровождаемым, и так далее.

\section{Кросс-компиляция (cross-compilation)}

Как вы знаете, программы редко работают ``просто на компьютере''. Как правило, программы работают в некотором окружении, в
которое, помимо собственно аппаратной платформы входит операционная система и набор пользовательских библиотек.

Поскольку компилятор сам по себе является программой, то он тоже работает в каком-то окружении (на какой-то аппаратной платформе
под управлением какой-то операцинной системы). Это окружение принято называть инструментальным. С другой стороны, компилятор порождает
некоторые программы, которые предназначены для работы в каком-то окружении. Это окружение называется целевым. В большинстве случаев
инструментальное окружение совпадает с целевым --- например, наш компилятор \lama работает под Linux на процессоре x86, и генерирует
код программ для x86, работающих под Linux.

Но так бывает не всегда. В ситуации, когда сам компилятор работает в одном окружении, а генерирует код для другого, его
называют кросс-компилятором. Типично использование кросс-компиляции для разработки встроенных систем, когда целевае окружение
в силу своей маломощности просто не в состоянии поддерживать исполнение компилятора. 

\section{Раскрутка}

Интересной и практически значимой операцией с использованием компилятора является его раскрутка (bootstrapping).
Под раскруткой понимают реализацию компилятора на его собственном исходном языке (например, реализацию компилятора C на C). Сам термин
``bootstrapping'' может использоваться в более широких контекстах и неформально обозначает процесс вытягивания самого себя куда-либо
(или откуда-либо) за петельки на ботинках (подобно тому, как барон Мюнхгаюзен вытянул себя за волосы из болота).

Раскрутка компилятора для нового языка (для которого еще нет ни одного компилятора) заключается в его реализации на каком-либо
другом языке и затем переписывание его на самом себе, используя полученный компилятор. Например, таким образом был раскручен компилятор \lama,
которым мы будем пользоваться~--- первоначально он был написан на языке OCaml, а затем переписан на самом себе.

Если компилятор существует, но работает на другой аппаратной платформе, то на ней с его помощью можно реализовать кросс-компилятор,
которым затем можно откомпилировать самого себя в код той платформы, которая нам интересна. Таким образом, например, получаются
реализации компилятора GCC для новых платформ.

Наконец, если совсем ничего не доступно, кроме ассемблера целевой платформы, то на этом ассемблере можно написать компилятор для
маленького подмножества целевого языка, на этим маленьком подмножестве написать компилятор для чуть более широкого подмножества, и
так далее пока мы не получим полноценный раскрученный компилятор.

Раскрутка компилятора важна по идеологическим причинам: во-первых, так доказывается выразительность языка, во-вторых, это
свидетельствует о зрелости самого компилятора, поскольку для нового языка его компилятор, как правило, является первой большой и сложной программой,
написанной на нем самом.

\section{Полная vs. частичная корректность}

Компилятор, будучи транслятором, синтаксически преобразует программу на одном языке программирования в программу на другом, сохраняя её семантику.
На практике, однако, существует одно важное обстоятельство. Мы будем говорить, что компилятор полностью корректен, если исходная и целевая программа
ведут себя неотличимо, а именно, на любых входных данных

\begin{enumerate}
\item если исходная программа завершается с каким-то результатом, то и
  целевая программа завершается с тем же результатом;
\item если целевая программа завершается с каким-то результатом, то и
  исходная программа завершается с тем же результатом.   
\end{enumerate}

Иными словами, и исходная, и целевая программы определены или неопределены одновременно, и если они определены, то их результаты совпадают.

Для большинства компиляторов, однако, пункт 2 этого требования не верен. <демонстрация>

Таким образом, компиляторам разрешается расширять область определения целевой программы, и таким образом они перестают быть полностью эквивалентными
исходным. Однако они остаются частично эквивалентыми, поскольку в тех случаях, когда исходная программа завершалась, они также
завершаются с тем же результатом. Компиляторы, которые порождают частично эквивалентные программы, называются частично корректными.

\section{Архитектура компиляторов}

С точки зрения архитектуры компиляторы в целом можно рассматривать как набор просмотров (passes), каждый из которых обрабатывает некоторое
промежуточное представление программы (intermediate representation). Конкретный набор как просмотров, так и форматов внутреннего представления
может отличаться от компилятора к компилятору. Среди наиболее употребимых внутренних представлений можно упомянуть абстрактное синтаксическое дерево
(abstract syntax tree), трехадресный код (three-address code), стековый код (stack machine code), статическую форму единственного присваивания (static
single assignment form, SSA) и другие. Некоторые из этих представлению будут нами использоваться при построении нашего компилятора, другие мы
оставим в стороне.

С точки зрения ассортимента просмотров в компиляторах как правило выделяют анализирующую и синтезирующую части. К анализирующей части относят,
прежде всего, синтаксический анализ и анализ типов (если в языке они есть). Существуют и другие задачи --- например, разрешение имен, работа с
областями видимости и т.д. Совокупность анализирующих просмотров часто объединяют понятием ``frontend'' (передняя часть компилятора).

К синтезирующей части относится деятельность по генерации машинного кода, например, выбор инструкций, распределение решистров, планирование и т.д.
Синтезирующие просмотры образуют так называемый ``backend'' компилятора, так сказать, его ``заднюю часть''.

Кроме этих двух компонент развитые компиляторы содержат набор оптимизирующий преобразований, который принято обозначать термином ``middle-end'',
так сказать, ``средняя часть'' компилятора. Количество просмотров в middle-end может быть достаточно велико, посколько существует более
десятка общеупотребимых оптимизирующих преобразований (некоторые указаны на слайде), котороые при компиляции могут повторяться.
<демонстрация>

\end{document}

